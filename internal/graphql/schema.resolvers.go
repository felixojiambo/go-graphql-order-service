package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.73

import (
	"context"
	"errors"

	"github.com/felixojiambo/go-graphql-order-service/internal/db"
	"github.com/google/uuid"
)

// Children resolves immediate subcategories for a Category.
func (r *categoryResolver) Children(ctx context.Context, obj *Category) ([]*Category, error) {
	cid, err := uuid.Parse(obj.ID)
	if err != nil {
		return nil, err
	}
	subs, err := r.CategoryRepo.ListChildren(ctx, &cid)
	if err != nil {
		return nil, err
	}
	var out []*Category
	for _, sub := range subs {
		out = append(out, &Category{
			ID:     sub.ID.String(),
			Name:   sub.Name,
			Parent: &Category{ID: obj.ID},
		})
	}
	return out, nil
}

// CreateCategory persists a new category.
func (r *mutationResolver) CreateCategory(ctx context.Context, input NewCategory) (*Category, error) {
	var parentID *uuid.UUID
	if input.ParentID != nil {
		pid, err := uuid.Parse(*input.ParentID)
		if err != nil {
			return nil, errors.New("invalid parentID")
		}
		parentID = &pid
	}

	dbCat := &db.Category{
		ID:       uuid.New(),
		Name:     input.Name,
		ParentID: parentID,
	}
	if err := r.CategoryRepo.Create(ctx, dbCat); err != nil {
		return nil, err
	}

	gqlCat := &Category{
		ID:   dbCat.ID.String(),
		Name: dbCat.Name,
	}
	if dbCat.ParentID != nil {
		gqlCat.Parent = &Category{ID: dbCat.ParentID.String()}
	}
	return gqlCat, nil
}

// CreateProduct persists a new product.
func (r *mutationResolver) CreateProduct(ctx context.Context, input NewProduct) (*Product, error) {
	catID, err := uuid.Parse(input.CategoryID)
	if err != nil {
		return nil, errors.New("invalid categoryID")
	}

	prod := &db.Product{
		ID:          uuid.New(),
		Name:        input.Name,
		Description: input.Description,
		Price:       input.Price,
		CategoryID:  catID,
	}
	if err := r.ProductRepo.Create(ctx, prod); err != nil {
		return nil, err
	}

	return &Product{
		ID:          prod.ID.String(),
		Name:        prod.Name,
		Description: prod.Description,
		Price:       prod.Price,
		Category:    &Category{ID: prod.CategoryID.String()},
	}, nil
}

// Categories returns all root categories.
func (r *queryResolver) Categories(ctx context.Context) ([]*Category, error) {
	dbCats, err := r.CategoryRepo.ListChildren(ctx, nil)
	if err != nil {
		return nil, err
	}
	var out []*Category
	for _, c := range dbCats {
		out = append(out, &Category{
			ID:   c.ID.String(),
			Name: c.Name,
		})
	}
	return out, nil
}

// ProductsByCategory returns all products in a category subtree.
func (r *queryResolver) ProductsByCategory(ctx context.Context, categoryID string) ([]*Product, error) {
	cid, err := uuid.Parse(categoryID)
	if err != nil {
		return nil, errors.New("invalid categoryID")
	}
	prods, err := r.ProductRepo.ListByCategory(ctx, cid)
	if err != nil {
		return nil, err
	}
	var out []*Product
	for _, p := range prods {
		out = append(out, &Product{
			ID:          p.ID.String(),
			Name:        p.Name,
			Description: p.Description,
			Price:       p.Price,
			Category:    &Category{ID: p.CategoryID.String()},
		})
	}
	return out, nil
}

// AveragePriceByCategory returns the average price of all products in a category subtree.
func (r *queryResolver) AveragePriceByCategory(ctx context.Context, categoryID string) (float64, error) {
	// parse & validate
	cid, err := uuid.Parse(categoryID)
	if err != nil {
		return 0, errors.New("invalid categoryID")
	}
	// delegate to repo
	return r.ProductRepo.AveragePriceByCategory(ctx, cid)
}

// Category returns CategoryResolver implementation.
func (r *Resolver) Category() CategoryResolver { return &categoryResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type categoryResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
